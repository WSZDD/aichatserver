import socket from '@ohos.net.socket';
import wifiManager from '@ohos.wifiManager';
import util from '@ohos.util';
import fs from '@ohos.file.fs';
import common from '@ohos.app.ability.common';
import { BusinessError } from '@ohos.base';
import promptAction from '@ohos.promptAction';
import taskpool from '@ohos.taskpool';
import emitter from '@ohos.events.emitter';

// å¼•å…¥åº“
import MNNNamespace from 'libmnnllm.so';

// ====================================================================
// ğŸ§µ åå°ä»»åŠ¡å®šä¹‰ (ä¿æŒä¸å˜)
// ====================================================================

// 1. åŠ è½½ä»»åŠ¡
@Concurrent
function nativeLoadTask(modelPath: string): boolean {
  const lib: ESObject = MNNNamespace;
  // å®‰å…¨è°ƒç”¨
  if (lib.nativeLoad) {
    return lib.nativeLoad(modelPath);
  }
  if (lib.default && lib.default.nativeLoad) {
    return lib.default.nativeLoad(modelPath);
  }
  return false;
}

// 2. æ¨ç†ä»»åŠ¡
@Concurrent
function nativeChatTask(question: string): string {
  const lib: ESObject = MNNNamespace;

  // å›è°ƒï¼šC++ æ¯ç”Ÿæˆä¸€ä¸ªå­—ï¼Œå°±é€šè¿‡ Emitter å‘å‡ºæ¥
  const onTokenCallback = (token: string): void => {
    emitter.emit({ eventId: 100 }, {
      data: { token: token }
    });
  };

  if (lib.nativeChat) {
    return lib.nativeChat(question, onTokenCallback);
  }
  if (lib.default && lib.default.nativeChat) {
    return lib.default.nativeChat(question, onTokenCallback);
  }
  return "Error";
}

// ====================================================================
// ğŸ“± ä¸»ç•Œé¢ (æœåŠ¡ç«¯)
// ====================================================================

@Entry
@Component
struct Index {
  @State logs: string[] = ["â³ ç³»ç»Ÿåˆå§‹åŒ–..."];
  @State ipAddress: string = "è·å–ä¸­...";
  @State modelStatus: string = "æœªåŠ è½½";
  @State clientStatus: string = "ç­‰å¾…è¿æ¥...";
  @State isModelLoading: boolean = false;
  @State currentReply: string = "";

  scroller: Scroller = new Scroller();
  private tcpServer: socket.TCPSocketServer | null = null;
  private activeClient: socket.TCPSocketConnection | null = null;

  // æ˜¾å¼ç±»å‹è½¬æ¢
  private context = getContext(this) as common.UIAbilityContext;
  private modelPath: string = this.context.filesDir + "/model.gguf";

  async aboutToAppear(): Promise<void> {
    this.getIpAddress();
    this.checkModelFile();

    // âœ… æ ¸å¿ƒä¿®å¤ï¼šç»™ eventData æ·»åŠ æ˜¾å¼ç±»å‹ emitter.EventData
    emitter.on({ eventId: 100 }, (eventData: emitter.EventData) => {
      // 1. ä½¿ç”¨ ESObject æ¥æ”¶ dataï¼Œé¿å¼€ç±»å‹æ£€æŸ¥
      const rawData: ESObject = eventData.data;

      if (rawData && rawData.token) {
        const token = rawData.token as string;

        // 2. æ›´æ–°æœ¬åœ°å±å¹•
        this.currentReply += token;

        // 3. å®æ—¶è½¬å‘ç»™å®¢æˆ·ç«¯
        if (this.activeClient) {
          this.activeClient.send({ data: token }).catch((err: BusinessError) => {
            // å¿½ç•¥å‘é€é”™è¯¯
          });
        }
      }
    });

    setTimeout(() => { this.initModel(); }, 1000);
  }

  checkModelFile(): void {
    try {
      if (fs.accessSync(this.modelPath)) {
        let stat = fs.statSync(this.modelPath);
        this.addLog(`âœ… æ¨¡å‹å°±ç»ª: ${(stat.size/1024/1024).toFixed(2)} MB`);
      } else {
        this.addLog(`âŒ æ¨¡å‹ä¸¢å¤±: ${this.modelPath}`);
      }
    } catch (e) { this.addLog(`Check Error: ${e}`); }
  }

  async initModel(): Promise<void> {
    if (this.isModelLoading) return;
    this.isModelLoading = true;
    this.addLog("ğŸ“¥ åå°åŠ è½½æ¨¡å‹ä¸­...");

    try {
      if (!fs.accessSync(this.modelPath)) {
        this.modelStatus = "âŒ æ–‡ä»¶ä¸¢å¤±";
        this.isModelLoading = false;
        return;
      }
      let sT = new Date().getTime();
      let task = new taskpool.Task(nativeLoadTask, this.modelPath);
      let success = await taskpool.execute(task) as boolean;

      if (success) {
        this.modelStatus = "âœ… æ¨¡å‹å·²åŠ è½½";
        this.addLog(`ğŸ‰ åŠ è½½è€—æ—¶: ${new Date().getTime() - sT}ms`);
        this.startTCPServer();
      } else {
        this.modelStatus = "âŒ åŠ è½½å¤±è´¥";
      }
    } catch (e) {
      this.modelStatus = "âŒ å´©æºƒ";
      this.addLog("Init Error: " + JSON.stringify(e));
    } finally {
      this.isModelLoading = false;
    }
  }

  async runChat(question: string): Promise<void> {
    this.currentReply = "";
    this.addLog("ğŸ¤– AI æ¨ç†ä¸­...");

    try {
      let task = new taskpool.Task(nativeChatTask, question);
      // ç­‰å¾… C++ æ¨ç†ä»»åŠ¡å½»åº•ç»“æŸ
      await taskpool.execute(task);
      this.addLog("âœ… å›å¤å®Œæˆ");

      // âœ¨ã€æ–°å¢ã€‘æ¨ç†ç»“æŸåï¼Œå‘é€ç»“æŸæ ‡è®°ç»™å®¢æˆ·ç«¯
      if (this.activeClient) {
        // å‘é€ä¸€ä¸ªç‰¹æ®Šçš„ç»“æŸç¬¦ï¼Œå®¢æˆ·ç«¯æ”¶åˆ°åä¼šéšè—å…‰æ ‡
        this.activeClient.send({ data: "[END]" }).catch(() => {});
      }

    } catch (e) {
      this.addLog("âŒ æ¨ç†é”™è¯¯: " + JSON.stringify(e));
    }
  }

  startTCPServer(): void {
    if (this.tcpServer) return;
    this.tcpServer = socket.constructTCPSocketServerInstance();

    class MyNetAddress implements socket.NetAddress {
      address: string = '0.0.0.0';
      port: number = 8765;
      family: number = 1;
    }
    let addr: socket.NetAddress = new MyNetAddress();

    this.tcpServer.listen(addr, (err: BusinessError) => {
      if (err) { this.addLog("ç«¯å£ 8765 è¢«å ç”¨"); return; }
      this.addLog("ğŸš€ TCP æœåŠ¡å¯åŠ¨");

      if(this.tcpServer) {
        this.tcpServer.on('connect', (clientSock) => {
          this.clientStatus = "ğŸ“± å®¢æˆ·ç«¯å·²è¿æ¥";
          this.addLog("ğŸ”” å®¢æˆ·ç«¯æ¥å…¥");

          this.activeClient = clientSock;

          clientSock.on('message', async (val) => {
            if (val.message instanceof ArrayBuffer) {
              let textDecoder = util.TextDecoder.create('utf-8');
              // è§£ç æ–‡æœ¬
              let text = textDecoder.decode(new Uint8Array(val.message));

              // ğŸ›‘ ã€æ ¸å¿ƒä¿®å¤ã€‘åœ¨æ­¤å¤„æ‹¦æˆªå¿ƒè·³åŒ…
              // å¦‚æœæ”¶åˆ°çš„æ˜¯ "ping"ï¼Œç›´æ¥å¿½ç•¥æˆ–ä»…æ‰“å°æ—¥å¿—ï¼Œç»å¯¹ä¸è¦è°ƒç”¨ runChat
              if (text.trim() === 'ping') {
                // this.addLog("ğŸ’“ æ”¶åˆ°å¿ƒè·³"); // å¦‚æœè§‰å¾—æ—¥å¿—å¤ªçƒ¦ï¼Œè¿™è¡Œä¹Ÿå¯ä»¥æ³¨é‡Šæ‰
                return; // ğŸ‘ˆ å…³é”®ï¼šç›´æ¥ç»“æŸå‡½æ•°ï¼Œä¸å¾€ä¸‹æ‰§è¡Œ
              }

              this.addLog("ğŸ‘¤ æ”¶åˆ°æŒ‡ä»¤: " + text);

              if (this.modelStatus.includes("âœ…")) {
                // åªæœ‰ä¸æ˜¯å¿ƒè·³åŒ…ï¼Œæ‰è®© AI å›å¤
                await this.runChat(text);
              } else {
                clientSock.send({ data: "Server Model Not Ready" });
              }
            }
          });

          clientSock.on('close', () => {
            this.clientStatus = "ç­‰å¾…è¿æ¥...";
            this.addLog("ğŸ“´ å®¢æˆ·ç«¯æ–­å¼€");
            this.activeClient = null;
          });

          clientSock.on('error', () => {
            this.activeClient = null;
          });
        });
      }
    });
  }

  getIpAddress(): void {
    try {
      let ipInfo = wifiManager.getIpInfo();
      let ip = ipInfo.ipAddress;
      this.ipAddress = ((ip>>>24)&0xFF)+"."+((ip>>16)&0xFF)+"."+((ip>>8)&0xFF)+"."+(ip&0xFF);
    } catch (e) {}
  }

  addLog(msg: string): void {
    console.info("[LLM_SERVER] " + msg);
    let time = new Date().toLocaleTimeString();
    this.logs.push(`[${time}] ${msg}`);
    setTimeout(() => { this.scroller.scrollEdge(Edge.Bottom); }, 100);
  }

  build() {
    Column() {
      Text("RK3588 ç«¯ä¾§å¤§æ¨¡å‹ (æœåŠ¡ç«¯)").fontSize(20).fontWeight(FontWeight.Bold).margin({ top: 20 })

      Row() {
        Text(this.modelStatus).fontColor(this.modelStatus.includes("âœ…") ? '#00AA00' : 'red').margin({right:10})
        Text(this.ipAddress + ":8765").fontColor('blue')
      }.margin(10)

      List({ scroller: this.scroller }) {
        ForEach(this.logs, (log: string) => {
          ListItem() { Text(log).fontSize(12).width('100%').fontColor('#666') }
        })
      }.height('25%').width('95%').backgroundColor('#F0F0F0').borderRadius(5)

      Divider().margin(10)

      // æ˜¾ç¤ºå½“å‰çš„å®æ—¶å›å¤
      Scroll() {
        Text(this.currentReply)
          .fontSize(18)
          .fontColor('#333')
          .padding(10)
      }
      .layoutWeight(1)
      .width('95%')
      .backgroundColor('#E6F7FF')
      .borderRadius(10)
      .align(Alignment.TopStart)

      Button(this.isModelLoading ? "åŠ è½½ä¸­..." : "æ‰‹åŠ¨æµ‹è¯•: ä½ å¥½")
        .onClick(async () => {
          if(!this.isModelLoading && this.modelStatus.includes("âœ…")) {
            await this.runChat("ä½ å¥½");
          } else {
            this.initModel();
          }
        })
        .margin(10)
    }
    .width('100%').height('100%')
  }
}