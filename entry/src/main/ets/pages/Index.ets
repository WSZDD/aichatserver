import socket from '@ohos.net.socket';
import wifiManager from '@ohos.wifiManager';
import util from '@ohos.util';
import fs from '@ohos.file.fs';
import common from '@ohos.app.ability.common';
import { BusinessError } from '@ohos.base';

// å¼•å…¥ Native åº“
import MNNNamespace from 'libmnnllm.so';

@Entry
@Component
struct Index {
  // --- UI çŠ¶æ€ ---
  @State logs: string[] = ["â³ ç³»ç»Ÿåˆå§‹åŒ–..."];
  @State ipAddress: string = "è·å–ä¸­...";
  @State asrStatus: string = "ASR: æœªåŠ è½½";
  @State llmStatus: string = "LLM: æœªåŠ è½½";
  @State ttsStatus: string = "TTS: æœªåŠ è½½";
  @State currentReply: string = "ç­‰å¾…è¾“å…¥...";

  scroller: Scroller = new Scroller();
  private tcpServer: socket.TCPSocketServer | null = null;
  private activeClient: socket.TCPSocketConnection | null = null;
  private context = getContext(this) as common.UIAbilityContext;

  // --- æ¨¡å‹è·¯å¾„ ---
  // ASR æ¨¡å‹ç›®å½•
  private asrModelPath: string = this.context.filesDir + "/sherpa_model";
  // LLM æ¨¡å‹æ–‡ä»¶
  private llmModelPath: string = this.context.filesDir + "/model.gguf";
  // TTS æ¨¡å‹ç›®å½•
  private ttsModelPath: string = this.context.filesDir + "/sherpa_tts_model";

  // --- æ ¸å¿ƒæ§åˆ¶å˜é‡ ---
  private pollTimer: number = -1;
  private isClientDoneSpeaking: boolean = false;
  private sessionTranscript: string = "";
  private isThinking: boolean = false;

  async aboutToAppear(): Promise<void> {
    this.getIpAddress();

    // 1. åˆå§‹åŒ–ä¸‰ä¸ªå¼•æ“ (ASR, LLM, TTS)
    this.initASR();
    this.initLLM();
    this.initTTS();

    // 2. å¯åŠ¨ TCP æœåŠ¡
    this.startTCPServer();
    this.addLog("âœ… å…¨æ ˆæœåŠ¡å°±ç»ª (è¯­éŸ³è¯†åˆ«+å¤§æ¨¡å‹+è¯­éŸ³åˆæˆ)");

    // 3. å¯åŠ¨ç»Ÿä¸€è½®è¯¢å¿ƒè·³ (50ms)
    this.pollTimer = setInterval(() => {
      this.pollSystemStatus();
    }, 50);
  }

  // =============================================================
  // ğŸ”¥ æ ¸å¿ƒå¾ªç¯ï¼šç»Ÿä¸€å¤„ç† ASR / LLM / TTS çš„çŠ¶æ€ ğŸ”¥
  // =============================================================
  pollSystemStatus() {
    try {
      const lib: ESObject = MNNNamespace;

      // --- [1] ASR éƒ¨åˆ†ï¼šå¬ ---
      if (lib.getRecognizedText) {
        let text = lib.getRecognizedText() as string;
        if (text && text.length > 0 && text !== this.sessionTranscript) {
          this.sessionTranscript = text;
          if (!this.isThinking) {
            this.currentReply = "ğŸ‘‚ å¬å–ä¸­: " + text;
          }
        }
      }

      // --- [2] LLM éƒ¨åˆ†ï¼šæƒ³ (æ–‡æœ¬æµ) ---
      if (this.isThinking && lib.getLlmResult) {
        let token = lib.getLlmResult() as string;
        if (token && token.length > 0) {
          if (this.currentReply === "ğŸ¤– æ€è€ƒä¸­...") this.currentReply = "";
          this.currentReply += token;

          // å®æ—¶å›ä¼ æ–‡æœ¬ç»™å®¢æˆ·ç«¯ UI æ˜¾ç¤º
          if (this.activeClient) {
            this.sendPacket(this.activeClient, 0x01, token);
          }
        }
      }

      // --- [3] TTS éƒ¨åˆ†ï¼šè¯´ (éŸ³é¢‘æµ) ---
      // ğŸ”¥ æ–°å¢ï¼šè½®è¯¢ C++ äº§ç”Ÿçš„ TTS éŸ³é¢‘æ•°æ®
      if (lib.getTtsAudio) {
        // ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šæ˜¾å¼ç±»å‹æ–­è¨€ as ArrayBufferï¼Œè§£å†³ ArkTS æŠ¥é”™ ğŸ”¥ğŸ”¥
        let pcmChunk = lib.getTtsAudio() as ArrayBuffer;

        if (pcmChunk && pcmChunk.byteLength > 0 && this.activeClient) {
          // å‘é€ 0x03 ç±»å‹åŒ… (Audio)
          this.sendPacket(this.activeClient, 0x03, pcmChunk);
        }
      }

      // --- [4] é€»è¾‘åˆ¤å®šï¼šASR æ˜¯å¦çœŸæ­£ç»“æŸ ---
      if (this.isClientDoneSpeaking && lib.getQueueSize) {
        let pendingSize = lib.getQueueSize() as number;
        if (pendingSize === 0) {
          this.handleAsrFinalResult(lib);
        }
      }
    } catch (e) {}
  }

  // ASR æœ€ç»ˆå¤„ç†ï¼šé‡ç½®è¯­éŸ³ -> è§¦å‘ LLM
  handleAsrFinalResult(lib: ESObject) {
    const userQuery = this.sessionTranscript;
    this.isClientDoneSpeaking = false;

    if (!userQuery || userQuery.trim().length === 0) {
      if (lib.resetSherpa) lib.resetSherpa();
      return;
    }

    this.addLog(`ğŸ—£ï¸ è¯­éŸ³æé—®: ${userQuery}`);

    // å›ä¼ ç”¨æˆ·è¯´çš„è¯ (ç¡®è®¤)
    if(this.activeClient) this.sendPacket(this.activeClient, 0x01, `[USER]: ${userQuery}\n`);

    // è§¦å‘ LLM
    this.triggerLLM(userQuery);

    // é‡ç½® ASR å¼•æ“
    if (lib.resetSherpa) lib.resetSherpa();
    this.sessionTranscript = "";
  }

  // ç»Ÿä¸€è§¦å‘ LLM æ¨ç†
  triggerLLM(query: string) {
    const lib: ESObject = MNNNamespace;

    // ğŸ”¥ å…³é”®ï¼šåœ¨å¼€å§‹æ–°ä¸€è½®å›ç­”å‰ï¼Œå¼ºåˆ¶æ‰“æ–­æ—§çš„ TTS æ’­æ”¾
    if (lib.stopTts) {
      lib.stopTts();
    }

    if (this.llmStatus.includes("âœ…") && lib.nativeChat) {
      this.isThinking = true;
      this.currentReply = "ğŸ¤– æ€è€ƒä¸­...";
      // C++ åå°çº¿ç¨‹å¼€å§‹è·‘ï¼Œä¼šè‡ªåŠ¨å°†ç”Ÿæˆçš„æ–‡æœ¬æ¨é€åˆ° TTS é˜Ÿåˆ—
      lib.nativeChat(query);
    } else {
      this.addLog("âš ï¸ LLM æœªå°±ç»ªï¼Œå¿½ç•¥æé—®");
      if(this.activeClient) this.sendPacket(this.activeClient, 0x01, "[ERROR] LLM Not Ready");
    }
  }

  // =============================================================
  // ğŸ“¡ TCP Server
  // =============================================================
  startTCPServer(): void {
    if (this.tcpServer) return;
    this.tcpServer = socket.constructTCPSocketServerInstance();
    this.tcpServer.listen({ address: '0.0.0.0', port: 8765, family: 1 }, (err: BusinessError) => {
      if (err) return;
      this.addLog("ğŸš€ Server Listening :8765");

      if(this.tcpServer) {
        this.tcpServer.on('connect', (clientSock) => {
          this.activeClient = clientSock;
          this.addLog("ğŸ”— å®¢æˆ·ç«¯å·²è¿æ¥");

          let buffer = new Uint8Array(0);

          clientSock.on('message', async (val) => {
            if (val.message instanceof ArrayBuffer) {
              let newPart = new Uint8Array(val.message);
              let temp = new Uint8Array(buffer.length + newPart.length);
              temp.set(buffer, 0);
              temp.set(newPart, buffer.length);
              buffer = temp;

              while (buffer.length >= 5) {
                let view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
                let type = view.getUint8(0);
                let len = view.getUint32(1);
                let packetLen = 5 + len;

                if (buffer.length < packetLen) break;

                let body = buffer.subarray(5, packetLen);

                // --- [1] çº¯æ–‡æœ¬æ¶ˆæ¯ ---
                if (type === 0x01) {
                  let text = new util.TextDecoder().decode(body);
                  if (text.trim() === 'ping') {
                    // å¿ƒè·³
                  } else if (text.includes("[VOICE_END]")) {
                    this.addLog("ğŸ¤ æ”¶åˆ°è¯­éŸ³ç»“æŸç¬¦");
                    this.isClientDoneSpeaking = true;
                  } else {
                    // æ–‡å­—èŠå¤©
                    this.addLog(`ğŸ“¨ æ”¶åˆ°æ–‡å­—: ${text}`);

                    // ğŸ”¥ æ‰“æ–­é€»è¾‘ï¼šç”¨æˆ·å‘æ–‡å­—ï¼Œç«‹å³åœæ­¢ ASR å’Œ TTS
                    const lib: ESObject = MNNNamespace;
                    if (lib.resetSherpa) lib.resetSherpa();
                    if (lib.stopTts) lib.stopTts();
                    this.sessionTranscript = "";

                    this.triggerLLM(text);
                  }

                }
                // --- [2] è¯­éŸ³æµè¾“å…¥ ---
                else if (type === 0x02) {
                  const lib: ESObject = MNNNamespace;

                  // ğŸ”¥ æ‰“æ–­é€»è¾‘ï¼šç”¨æˆ·å¼€å§‹è¯´è¯ï¼Œç«‹å³åœæ­¢æœºå™¨äººçš„ TTS
                  if (lib.stopTts) lib.stopTts();

                  if (lib.acceptWaveform) {
                    lib.acceptWaveform(body.slice(0).buffer);
                  }
                }

                buffer = buffer.slice(packetLen);
              }
            }
          });

          clientSock.on('close', () => { this.activeClient = null; this.addLog("å®¢æˆ·ç«¯æ–­å¼€"); });
          clientSock.on('error', () => { this.activeClient = null; });
        });
      }
    });
  }

  // =============================================================
  // ğŸ› ï¸ åˆå§‹åŒ–ä¸å·¥å…·å‡½æ•°
  // =============================================================

  initLLM() {
    try {
      const lib: ESObject = MNNNamespace;
      if (!fs.accessSync(this.llmModelPath)) {
        this.llmStatus = "âŒ model.ggufç¼ºå¤±";
        return;
      }
      this.addLog("â³ åˆå§‹åŒ– LLM...");
      if (lib.nativeLoad) {
        let ret = lib.nativeLoad(this.llmModelPath) as boolean;
        this.llmStatus = ret ? "âœ… LLM å°±ç»ª" : "âŒ LLM å¤±è´¥";
        if(ret) this.addLog("ğŸ§  å¤§æ¨¡å‹åŠ è½½å®Œæˆ");
      }
    } catch (e) { this.llmStatus = "âŒ LLM Error"; }
  }

  initASR() {
    try {
      const lib: ESObject = MNNNamespace;
      if (!fs.accessSync(this.asrModelPath + "/tokens.txt")) {
        this.asrStatus = "âŒ ASRæ¨¡å‹ç¼ºå¤±";
        return;
      }
      if (lib.initSherpa) {
        let ret = lib.initSherpa(this.asrModelPath) as boolean;
        if (ret) this.asrStatus = "âœ… Sherpa å°±ç»ª";
      }
    } catch (e) { this.asrStatus = "âŒ ASR Init Error"; }
  }

  initTTS() {
    try {
      const lib: ESObject = MNNNamespace;

      // 1. æ‰“å°å½“å‰å®é™…è·¯å¾„ï¼Œæ–¹ä¾¿è°ƒè¯•
      this.addLog("ğŸ“‚ æ£€æŸ¥è·¯å¾„: " + this.ttsModelPath);

      // 2. æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨
      if (!fs.accessSync(this.ttsModelPath)) {
        this.ttsStatus = "âŒ ç›®å½•ä¸å­˜åœ¨";
        this.addLog("âš ï¸ è¯·æ£€æŸ¥ HDC æ¨é€è·¯å¾„ï¼");
        return;
      }

      // 3. æ£€æŸ¥æ ¸å¿ƒæ–‡ä»¶ config.json
      if (!fs.accessSync(this.ttsModelPath + "/config.json")) {
        this.ttsStatus = "âŒ ç¼ºå°‘ config.json";
        return;
      }

      // 4. ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šè‡ªåŠ¨æ¸…æ´— tokens.txt çš„æ¢è¡Œç¬¦ ğŸ”¥
      // Windows è®°äº‹æœ¬ä¿å­˜çš„ \r\n ä¼šå¯¼è‡´ Sherpa ç›´æ¥å´©æºƒ (13900012)
      let tokensPath = this.ttsModelPath + "/tokens.txt";
      if (fs.accessSync(tokensPath)) {
        let content = fs.readTextSync(tokensPath);
        if (content.includes('\r')) {
          this.addLog("ğŸ”§ ä¿®å¤ tokens.txt æ ¼å¼...");
          // æ›¿æ¢æ‰æ‰€æœ‰ \rï¼Œåªä¿ç•™ \n
          let fixedContent = content.replace(/\r/g, '');
          let file = fs.openSync(tokensPath, fs.OpenMode.READ_WRITE | fs.OpenMode.TRUNC);
          fs.writeSync(file.fd, fixedContent);
          fs.closeSync(file);
        }
      } else {
        this.ttsStatus = "âŒ ç¼ºå°‘ tokens.txt";
        return;
      }

      // 5. æ£€æŸ¥ espeak æ•°æ®
      let espeakPath = this.ttsModelPath + "/espeak-ng-data";
      if (!fs.accessSync(espeakPath) || !fs.listFileSync(espeakPath).length) {
        this.ttsStatus = "âŒ espeak ç¼ºå¤±/ä¸ºç©º";
        return;
      }

      // 6. ä¸€åˆ‡æ­£å¸¸ï¼Œæ‰æ•¢è°ƒç”¨ C++
      this.addLog("ğŸš€ å¼€å§‹åŠ è½½ C++ TTS...");
      if (lib.initTts) {
        let ret = lib.initTts(this.ttsModelPath) as boolean;
        if (ret) {
          this.ttsStatus = "âœ… TTS å°±ç»ª";
        } else {
          this.ttsStatus = "âŒ C++ åˆå§‹åŒ–å¤±è´¥";
        }
      }
    } catch (e) {
      this.ttsStatus = "âŒ TSå±‚å¼‚å¸¸";
      console.error("TTS Init Error: " + JSON.stringify(e));
      this.addLog("Error: " + JSON.stringify(e));
    }
  }

  sendPacket(client: socket.TCPSocketConnection, type: number, data: string | ArrayBuffer) {
    if (!client) return;

    let contentBytes: Uint8Array;
    if (typeof data === 'string') {
      contentBytes = new util.TextEncoder().encodeInto(data);
    } else {
      contentBytes = new Uint8Array(data);
    }

    let packet = new Uint8Array(1 + 4 + contentBytes.length);
    let view = new DataView(packet.buffer);
    view.setUint8(0, type);
    view.setUint32(1, contentBytes.length);
    packet.set(contentBytes, 5);

    client.send({ data: packet.buffer as ArrayBuffer }).catch(() => {});
  }

  getIpAddress(): void {
    try {
      let ipInfo = wifiManager.getIpInfo();
      let ip = ipInfo.ipAddress;
      this.ipAddress = ((ip>>>24)&0xFF)+"."+((ip>>16)&0xFF)+"."+((ip>>8)&0xFF)+"."+(ip&0xFF);
    } catch(e) { this.ipAddress = "127.0.0.1"; }
  }

  addLog(msg: string): void {
    if (this.logs.length > 20) this.logs.shift();
    this.logs.push(`[${new Date().toLocaleTimeString()}] ${msg}`);
  }

  build() {
    Column() {
      Text("RK3568 AI èåˆæœåŠ¡ç«¯").fontSize(18).fontWeight(FontWeight.Bold).margin(15)

      // çŠ¶æ€æ 
      Row() {
        Text(this.ipAddress + ":8765").fontColor('blue').fontSize(12)
        Divider().vertical(true).height(15).margin(5)
        Text(this.asrStatus).fontColor(this.asrStatus.includes("âœ…") ? 'green' : 'red').fontSize(12)
        Divider().vertical(true).height(15).margin(5)
        Text(this.llmStatus).fontColor(this.llmStatus.includes("âœ…") ? 'green' : 'red').fontSize(12)
        Divider().vertical(true).height(15).margin(5)
        Text(this.ttsStatus).fontColor(this.ttsStatus.includes("âœ…") ? 'green' : 'red').fontSize(12)
      }.margin({bottom: 10})

      // æ—¥å¿—åŒº
      List({ scroller: this.scroller }) {
        ForEach(this.logs, (log: string) => {
          ListItem() { Text(log).fontSize(11).fontColor('#666').margin({bottom:2}) }
        })
      }.height('25%').width('95%').backgroundColor('#F2F2F2').borderRadius(5)

      // äº¤äº’æ˜¾ç¤ºåŒº
      Text(this.currentReply)
        .fontSize(22).fontColor('#333').fontWeight(FontWeight.Bold)
        .padding(15).width('95%').layoutWeight(1)
        .backgroundColor('#E6F7FF').margin({top:10}).borderRadius(10)
        .align(Alignment.TopStart)

      // æ‰‹åŠ¨æµ‹è¯•æŒ‰é’®
      Row() {
        Button("æµ‹è¯•: ä½ å¥½")
          .onClick(() => {
            this.addLog("ğŸ–±ï¸ æ‰‹åŠ¨è§¦å‘æ–‡å­—");
            this.triggerLLM("ä½ å¥½");
          })
          .margin(5)

        Button("æ‰“æ–­è¯´è¯")
          .backgroundColor('#FF5252')
          .onClick(() => {
            const lib: ESObject = MNNNamespace;
            if (lib.stopTts) {
              lib.stopTts();
              this.addLog("ğŸ›‘ å¼ºåˆ¶åœæ­¢ TTS");
            }
          })
          .margin(5)
      }.margin(10)
    }
    .width('100%').height('100%')
  }
}