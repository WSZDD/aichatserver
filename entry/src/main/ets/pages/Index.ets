import socket from '@ohos.net.socket';
import wifiManager from '@ohos.wifiManager';
import util from '@ohos.util';
import fs from '@ohos.file.fs';
import common from '@ohos.app.ability.common';
import { BusinessError } from '@ohos.base';

// å¼•å…¥ Native åº“
import MNNNamespace from 'libmnnllm.so';

@Entry
@Component
struct Index {
  // --- UI çŠ¶æ€ ---
  @State logs: string[] = ["â³ ç³»ç»Ÿåˆå§‹åŒ–..."];
  @State ipAddress: string = "è·å–ä¸­...";
  @State asrStatus: string = "ASR: æœªåŠ è½½";
  @State llmStatus: string = "LLM: æœªåŠ è½½";
  @State currentReply: string = "ç­‰å¾…è¾“å…¥..."; // ç»Ÿä¸€æ˜¾ç¤º ASR æˆ– LLM çš„å†…å®¹

  scroller: Scroller = new Scroller();
  private tcpServer: socket.TCPSocketServer | null = null;
  private activeClient: socket.TCPSocketConnection | null = null;
  private context = getContext(this) as common.UIAbilityContext;

  // --- æ¨¡å‹è·¯å¾„ ---
  private asrModelPath: string = this.context.filesDir + "/sherpa_model";
  private llmModelPath: string = this.context.filesDir + "/model.gguf";

  // --- æ ¸å¿ƒæ§åˆ¶å˜é‡ ---
  private pollTimer: number = -1;
  private isClientDoneSpeaking: boolean = false; // å®¢æˆ·ç«¯å‘é€ [VOICE_END] æ ‡è®°
  private sessionTranscript: string = "";        // å½“å‰è¯†åˆ«åˆ°çš„å®Œæ•´å¥å­
  private isThinking: boolean = false;           // æ ‡è®° LLM æ˜¯å¦æ­£åœ¨ç”Ÿæˆ

  async aboutToAppear(): Promise<void> {
    this.getIpAddress();

    // 1. åˆå§‹åŒ–ä¸¤ä¸ªå¼•æ“
    this.initASR();
    this.initLLM();

    // 2. å¯åŠ¨ TCP æœåŠ¡
    this.startTCPServer();
    this.addLog("âœ… åŒæ¨¡æœåŠ¡å°±ç»ª (è¯­éŸ³+æ–‡å­—)");

    // 3. å¯åŠ¨ç»Ÿä¸€è½®è¯¢å¿ƒè·³ (50ms)
    // æ›¿ä»£äº† Taskpoolï¼Œé€šè¿‡æŸ¥è¯¢ C++ çŠ¶æ€æ¥æ›´æ–° UI
    this.pollTimer = setInterval(() => {
      this.pollSystemStatus();
    }, 50);
  }

  // =============================================================
  // ğŸ”¥ æ ¸å¿ƒå¾ªç¯ï¼šç»Ÿä¸€å¤„ç† ASR å’Œ LLM çš„çŠ¶æ€ ğŸ”¥
  // =============================================================
  pollSystemStatus() {
    try {
      const lib: ESObject = MNNNamespace;

      // --- [1] ASR éƒ¨åˆ†ï¼šå¬ ---
      // åªè¦ C++ æœ‰è¯†åˆ«ç»“æœï¼Œå°±æ‹¿å‡ºæ¥æ˜¾ç¤ºï¼Œä½†ä¸ä¸€å®šå‘ç»™å®¢æˆ·ç«¯
      if (lib.getRecognizedText) {
        let text = lib.getRecognizedText() as string;
        if (text && text.length > 0 && text !== this.sessionTranscript) {
          this.sessionTranscript = text;
          // å¦‚æœæ²¡åœ¨æ€è€ƒï¼Œå°±æ˜¾ç¤ºå¬åˆ°çš„å†…å®¹
          if (!this.isThinking) {
            this.currentReply = "ğŸ‘‚ å¬å–ä¸­: " + text;
          }
        }
      }

      // --- [2] LLM éƒ¨åˆ†ï¼šè¯´ ---
      // å¦‚æœæ­£åœ¨æ¨ç†ï¼Œä¸æ–­è½®è¯¢ç”Ÿæˆçš„ Token
      if (this.isThinking && lib.getLlmResult) {
        let token = lib.getLlmResult() as string;
        if (token && token.length > 0) {
          // ç¬¬ä¸€æ¬¡æ”¶åˆ° Token æ—¶æ¸…é™¤ "æ€è€ƒä¸­..."
          if (this.currentReply === "ğŸ¤– æ€è€ƒä¸­...") this.currentReply = "";

          this.currentReply += token; // æ›´æ–°æœ¬åœ° UI

          // å®æ—¶æµå¼å›ä¼ ç»™å®¢æˆ·ç«¯
          if (this.activeClient) {
            this.sendPacket(this.activeClient, 0x01, token);
          }
        }
      }

      // --- [3] é€»è¾‘åˆ¤å®šï¼šASR æ˜¯å¦çœŸæ­£ç»“æŸ ---
      // æ¡ä»¶ï¼šå®¢æˆ·ç«¯å‘äº†ç»“æŸç¬¦ AND C++åå°é˜Ÿåˆ—å¤„ç†å®Œæ¯•
      if (this.isClientDoneSpeaking && lib.getQueueSize) {
        let pendingSize = lib.getQueueSize() as number;
        if (pendingSize === 0) {
          this.handleAsrFinalResult(lib);
        }
      }
    } catch (e) {}
  }

  // ASR æœ€ç»ˆå¤„ç†ï¼šé‡ç½®è¯­éŸ³ -> è§¦å‘ LLM
  handleAsrFinalResult(lib: ESObject) {
    const userQuery = this.sessionTranscript;
    this.isClientDoneSpeaking = false; // é‡ç½®æ ‡è®°

    // å¦‚æœæ˜¯ç©ºè¯­éŸ³ï¼Œç›´æ¥é‡ç½®
    if (!userQuery || userQuery.trim().length === 0) {
      if (lib.resetSherpa) lib.resetSherpa();
      return;
    }

    this.addLog(`ğŸ—£ï¸ è¯­éŸ³æé—®: ${userQuery}`);

    // å›ä¼ ç”¨æˆ·è¯´çš„è¯ (ç¡®è®¤)
    if(this.activeClient) this.sendPacket(this.activeClient, 0x01, `[USER]: ${userQuery}\n`);

    // è§¦å‘ LLM
    this.triggerLLM(userQuery);

    // é‡ç½® ASR å¼•æ“
    if (lib.resetSherpa) lib.resetSherpa();
    this.sessionTranscript = "";
  }

  // ç»Ÿä¸€è§¦å‘ LLM æ¨ç†
  triggerLLM(query: string) {
    const lib: ESObject = MNNNamespace;
    if (this.llmStatus.includes("âœ…") && lib.nativeChat) {
      this.isThinking = true;
      this.currentReply = "ğŸ¤– æ€è€ƒä¸­...";
      // éé˜»å¡è°ƒç”¨ï¼ŒC++ åå°çº¿ç¨‹å¼€å§‹è·‘ï¼Œæˆ‘ä»¬é€šè¿‡ pollSystemStatus å–ç»“æœ
      lib.nativeChat(query);
    } else {
      this.addLog("âš ï¸ LLM æœªå°±ç»ªï¼Œå¿½ç•¥æé—®");
      if(this.activeClient) this.sendPacket(this.activeClient, 0x01, "[ERROR] LLM Not Ready");
    }
  }

  // =============================================================
  // ğŸ“¡ TCP Server (åŒ…å«æ—§ç‰ˆçš„ç²˜åŒ…å¤„ç† + æ–°ç‰ˆçš„æ¥å£è°ƒç”¨)
  // =============================================================
  startTCPServer(): void {
    if (this.tcpServer) return;
    this.tcpServer = socket.constructTCPSocketServerInstance();
    this.tcpServer.listen({ address: '0.0.0.0', port: 8765, family: 1 }, (err: BusinessError) => {
      if (err) return;
      this.addLog("ğŸš€ Server Listening :8765");

      if(this.tcpServer) {
        this.tcpServer.on('connect', (clientSock) => {
          this.activeClient = clientSock;
          this.addLog("ğŸ”— å®¢æˆ·ç«¯å·²è¿æ¥");

          // æ¥æ”¶ç¼“å†²åŒº
          let buffer = new Uint8Array(0);

          clientSock.on('message', async (val) => {
            if (val.message instanceof ArrayBuffer) {
              // 1. æ‹¼æ¥æ–°æ•°æ®åˆ°ç¼“å†²åŒº
              let newPart = new Uint8Array(val.message);
              let temp = new Uint8Array(buffer.length + newPart.length);
              temp.set(buffer, 0);
              temp.set(newPart, buffer.length);
              buffer = temp;

              // 2. å¾ªç¯å¤„ç†ç¼“å†²åŒºä¸­çš„å®Œæ•´åŒ…
              while (buffer.length >= 5) { // è‡³å°‘è¦æœ‰å¤´éƒ¨ (1å­—èŠ‚ç±»å‹ + 4å­—èŠ‚é•¿åº¦)
                let view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
                let type = view.getUint8(0);
                let len = view.getUint32(1);
                let packetLen = 5 + len;

                // æ•°æ®ä¸å¤Ÿä¸€ä¸ªå®Œæ•´åŒ…ï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡
                if (buffer.length < packetLen) break;

                // æå–åŒ…ä½“
                let body = buffer.subarray(5, packetLen);

                // --- ä¸šåŠ¡é€»è¾‘å¤„ç† ---
                if (type === 0x01) { // [çº¯æ–‡æœ¬]
                  let text = new util.TextDecoder().decode(body);
                  if (text.trim() === 'ping') {
                    // å¯ä»¥é€‰æ‹©ä¸æ‰“å°æ—¥å¿—ï¼Œä»¥å…åˆ·å±
                    // this.addLog("â¤ï¸ å¿ƒè·³");
                  }else if (text.includes("[VOICE_END]")) {
                    this.addLog("ğŸ¤ æ”¶åˆ°è¯­éŸ³ç»“æŸç¬¦");
                    // æ ‡è®°ç»“æŸï¼Œå‰©ä¸‹çš„äº¤ç»™è½®è¯¢å™¨å»æŸ¥ C++ é˜Ÿåˆ—
                    this.isClientDoneSpeaking = true;
                  } else {
                    // æ™®é€šæ–‡å­—èŠå¤©ï¼šç›´æ¥è§¦å‘ LLM
                    this.addLog(`ğŸ“¨ æ”¶åˆ°æ–‡å­—: ${text}`);
                    // æ‰“æ–­å½“å‰çš„è¯­éŸ³è¯†åˆ«ï¼ˆå¦‚æœæœ‰ï¼‰
                    const lib: ESObject = MNNNamespace;
                    if (lib.resetSherpa) lib.resetSherpa();
                    this.sessionTranscript = "";

                    this.triggerLLM(text);
                  }

                } else if (type === 0x02) { // [è¯­éŸ³æµ]
                  const lib: ESObject = MNNNamespace;
                  if (lib.acceptWaveform) {
                    // ç›´æ¥å¡å…¥ C++ é˜Ÿåˆ—ï¼Œä¸åšä»»ä½• JS å±‚ç¼“å†²ï¼Œé€Ÿåº¦æœ€å¿«
                    lib.acceptWaveform(body.slice(0).buffer);
                  }
                }

                // ç§»é™¤å·²å¤„ç†çš„åŒ…
                buffer = buffer.slice(packetLen);
              }
            }
          });

          clientSock.on('close', () => { this.activeClient = null; this.addLog("å®¢æˆ·ç«¯æ–­å¼€"); });
          clientSock.on('error', () => { this.activeClient = null; });
        });
      }
    });
  }

  // =============================================================
  // ğŸ› ï¸ åˆå§‹åŒ–ä¸å·¥å…·å‡½æ•°
  // =============================================================

  initLLM() {
    try {
      const lib: ESObject = MNNNamespace;
      if (!fs.accessSync(this.llmModelPath)) {
        this.llmStatus = "âŒ model.ggufç¼ºå¤±";
        return;
      }
      this.addLog("â³ åˆå§‹åŒ– LLM (åå°çº¿ç¨‹)...");
      if (lib.nativeLoad) {
        // æ˜¾å¼ç±»å‹æ–­è¨€ï¼Œé˜²æ­¢ ArkTS æŠ¥é”™
        let ret = lib.nativeLoad(this.llmModelPath) as boolean;
        if (ret) {
          this.llmStatus = "âœ… LLM å°±ç»ª";
          this.addLog("ğŸ§  å¤§æ¨¡å‹åŠ è½½å®Œæˆ");
        } else {
          this.llmStatus = "âŒ LLM åŠ è½½å¤±è´¥";
        }
      }
    } catch (e) { this.llmStatus = "âŒ LLM Error"; }
  }

  initASR() {
    try {
      const lib: ESObject = MNNNamespace;
      if (!fs.accessSync(this.asrModelPath + "/tokens.txt")) {
        this.asrStatus = "âŒ ASRæ¨¡å‹ç¼ºå¤±";
        return;
      }
      if (lib.initSherpa) {
        // æ˜¾å¼ç±»å‹æ–­è¨€
        let ret = lib.initSherpa(this.asrModelPath) as boolean;
        if (ret) this.asrStatus = "âœ… Sherpa å°±ç»ª";
      }
    } catch (e) { this.asrStatus = "âŒ Init Error"; }
  }

  sendPacket(client: socket.TCPSocketConnection, type: number, data: string) {
    if (!client) return;
    let contentBytes = new util.TextEncoder().encodeInto(data);
    let packet = new Uint8Array(1 + 4 + contentBytes.length);
    let view = new DataView(packet.buffer);
    view.setUint8(0, type);
    view.setUint32(1, contentBytes.length);
    packet.set(contentBytes, 5);
    client.send({ data: packet.buffer as ArrayBuffer }).catch(() => {});
  }

  getIpAddress(): void {
    try {
      let ipInfo = wifiManager.getIpInfo();
      let ip = ipInfo.ipAddress;
      this.ipAddress = ((ip>>>24)&0xFF)+"."+((ip>>16)&0xFF)+"."+((ip>>8)&0xFF)+"."+(ip&0xFF);
    } catch(e) { this.ipAddress = "127.0.0.1"; }
  }

  addLog(msg: string): void {
    if (this.logs.length > 20) this.logs.shift();
    this.logs.push(`[${new Date().toLocaleTimeString()}] ${msg}`);
  }

  // =============================================================
  // ğŸ¨ UI å¸ƒå±€
  // =============================================================
  build() {
    Column() {
      Text("RK3568 AI èåˆæœåŠ¡ç«¯").fontSize(18).fontWeight(FontWeight.Bold).margin(15)

      // çŠ¶æ€æ 
      Row() {
        Text(this.ipAddress + ":8765").fontColor('blue').fontSize(12)
        Divider().vertical(true).height(15).margin(5)
        Text(this.asrStatus).fontColor(this.asrStatus.includes("âœ…") ? 'green' : 'red').fontSize(12)
        Divider().vertical(true).height(15).margin(5)
        Text(this.llmStatus).fontColor(this.llmStatus.includes("âœ…") ? 'green' : 'red').fontSize(12)
      }.margin({bottom: 10})

      // æ—¥å¿—åŒº
      List({ scroller: this.scroller }) {
        ForEach(this.logs, (log: string) => {
          ListItem() { Text(log).fontSize(11).fontColor('#666').margin({bottom:2}) }
        })
      }.height('25%').width('95%').backgroundColor('#F2F2F2').borderRadius(5)

      // äº¤äº’æ˜¾ç¤ºåŒº (ASRå®æ—¶ç»“æœ æˆ– LLMå›ç­”)
      Text(this.currentReply)
        .fontSize(22).fontColor('#333').fontWeight(FontWeight.Bold)
        .padding(15).width('95%').layoutWeight(1)
        .backgroundColor('#E6F7FF').margin({top:10}).borderRadius(10)
        .align(Alignment.TopStart)

      // æ‰‹åŠ¨æµ‹è¯•æŒ‰é’®
      Button("æ‰‹åŠ¨æµ‹è¯•: ä½ å¥½")
        .onClick(() => {
          this.addLog("ğŸ–±ï¸ æ‰‹åŠ¨è§¦å‘");
          this.triggerLLM("ä½ å¥½");
        })
        .margin(10)
    }
    .width('100%').height('100%')
  }
}